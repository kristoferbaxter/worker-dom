{"version":3,"file":"debug.js","sources":["../output/worker-dom-consumer/src/nodes.js","../output/worker-dom-consumer/src/worker.js","../output/worker-dom-consumer/src/command.js","../output/worker-dom-consumer/src/hydrate.js","../output/worker-dom-consumer/src/mutate.js","../output/worker-dom-consumer/src/install.js","../output/worker-dom-consumer/src/index.js"],"sourcesContent":["/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet NODES;\nlet BASE_ELEMENT;\nexport function prepare(baseElement) {\n    NODES = new Map([[1, baseElement], [2, baseElement]]);\n    BASE_ELEMENT = baseElement;\n}\n/**\n * Create a real DOM Node from a skeleton Object (`{ nodeType, nodeName, attributes, children, data }`)\n * @example <caption>Text node</caption>\n *   createNode({ nodeType:3, data:'foo' })\n * @example <caption>Element node</caption>\n *   createNode({ nodeType:1, nodeName:'div', attributes:[{ name:'a', value:'b' }], childNodes:[ ... ] })\n */\nexport function createNode(skeleton) {\n    if (skeleton[0 /* nodeType */] === Node.TEXT_NODE) {\n        const node = document.createTextNode(skeleton[5 /* textContent */]);\n        storeNode(node, skeleton[7 /* _index_ */]);\n        return node;\n    }\n    const namespace = skeleton[6 /* namespaceURI */];\n    const node = namespace\n        ? document.createElementNS(namespace, skeleton[1 /* nodeName */])\n        : document.createElement(skeleton[1 /* nodeName */]);\n    (skeleton[2 /* attributes */] || []).forEach(attribute => {\n        if (attribute.namespaceURI) {\n            node.setAttributeNS(attribute.namespaceURI, attribute.name, attribute.value);\n        }\n        else {\n            node.setAttribute(attribute.name, attribute.value);\n        }\n    });\n    // TODO(KB): Restore Properties\n    // skeleton.properties.forEach(property => {\n    //   node[`${property.name}`] = property.value;\n    // });\n    (skeleton[4 /* childNodes */] || []).forEach(childNode => {\n        if (childNode[8 /* transferred */] === 0 /* FALSE */) {\n            node.appendChild(createNode(childNode));\n        }\n    });\n    storeNode(node, skeleton[7 /* _index_ */]);\n    return node;\n}\n/**\n * Returns the real DOM Element corresponding to a serialized Element object.\n * @param id\n * @return\n */\nexport function getNode(id) {\n    const node = NODES.get(id);\n    if (node && node.nodeName === 'BODY') {\n        // If the node requested is the \"BODY\"\n        // Then we return the base node this specific <amp-script> comes from.\n        // This encapsulates each <amp-script> node.\n        return BASE_ELEMENT;\n    }\n    return node;\n}\n/**\n * Establish link between DOM `node` and worker-generated identifier `id`.\n *\n * These _shouldn't_ collide between instances of <amp-script> since\n * each element creates it's own pool on both sides of the worker\n * communication bridge.\n * @param node\n * @param id\n */\nexport function storeNode(node, id) {\n    node._index_ = id;\n    NODES.set(id, node);\n}\n//# sourceMappingURL=nodes.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(KB): Fetch Polyfill for IE11.\nexport function createWorker(authorScriptURL) {\n    return Promise.all([fetch(__WORKER_DOM_URL__).then(response => response.text()), fetch(authorScriptURL).then(response => response.text())])\n        .then(([workerScript, authorScript]) => {\n        // TODO(KB): Minify this output during build process.\n        const keys = [];\n        for (let key in document.body.style) {\n            keys.push(`'${key}'`);\n        }\n        const code = `\n        'use strict';\n        ${workerScript}\n        (function() {\n          var self = this;\n          var document = this.document;\n          var localStorage = this.localStorage;\n          var location = this.location;\n          var defaultView = document.defaultView;\n          var Node = defaultView.Node;\n          var Text = defaultView.Text;\n          var Element = defaultView.Element;\n          var SVGElement = defaultView.SVGElement;\n          var Document = defaultView.Document;\n          var Event = defaultView.Event;\n          var MutationObserver = defaultView.MutationObserver;\n\n          function addEventListener(type, handler) {\n            return document.addEventListener(type, handler);\n          }\n          function removeEventListener(type, handler) {\n            return document.removeEventListener(type, handler);\n          }\n          this.appendKeys([${keys}]);\n          ${authorScript}\n        }).call(WorkerThread.monkey);`;\n        return new Worker(URL.createObjectURL(new Blob([code])));\n    })\n        .catch(error => {\n        return null;\n    });\n}\nexport function messageToWorker(worker, message) {\n    worker.postMessage(message);\n}\n//# sourceMappingURL=worker.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { messageToWorker } from './worker';\nimport { getNode } from './nodes';\nconst KNOWN_LISTENERS = [];\n/**\n * Instead of a whitelist of elements that need their value tracked, use the existence\n * of a property called value to drive the decision.\n * @param node node to check if values should be tracked.\n * @return boolean if the node should have its value property tracked.\n */\nconst shouldTrackChanges = (node) => node && 'value' in node;\n/**\n * When a node that has a value needing synced doesn't already have an event listener\n * listening for changed values, ensure the value is synced with a default listener.\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const applyDefaultChangeListener = (worker, node) => {\n    shouldTrackChanges(node) && node.onchange === null && (node.onchange = () => fireValueChange(worker, node));\n};\n/**\n * Tell the worker DOM what the value is for a Node.\n * @param worker whom to dispatch value toward.\n * @param node where to get the value from.\n */\nconst fireValueChange = (worker, node) => {\n    messageToWorker(worker, {\n        [9 /* type */]: 5 /* SYNC */,\n        [36 /* sync */]: {\n            [7 /* _index_ */]: node._index_,\n            [18 /* value */]: node.value,\n        },\n    });\n};\n/**\n * Register an event handler for dispatching events to worker thread\n * @param worker whom to dispatch events toward\n * @param _index_ node index the event comes from (used to dispatchEvent in worker thread).\n * @return eventHandler function consuming event and dispatching to worker thread\n */\nconst eventHandler = (worker, _index_) => (event) => {\n    if (shouldTrackChanges(event.currentTarget)) {\n        fireValueChange(worker, event.currentTarget);\n    }\n    messageToWorker(worker, {\n        [9 /* type */]: 1 /* EVENT */,\n        [35 /* event */]: {\n            [7 /* _index_ */]: _index_,\n            [22 /* bubbles */]: event.bubbles,\n            [23 /* cancelable */]: event.cancelable,\n            [24 /* cancelBubble */]: event.cancelBubble,\n            [25 /* currentTarget */]: {\n                [7 /* _index_ */]: event.currentTarget._index_,\n                [8 /* transferred */]: 1 /* TRUE */,\n            },\n            [26 /* defaultPrevented */]: event.defaultPrevented,\n            [27 /* eventPhase */]: event.eventPhase,\n            [28 /* isTrusted */]: event.isTrusted,\n            [29 /* returnValue */]: event.returnValue,\n            [10 /* target */]: {\n                [7 /* _index_ */]: event.target._index_,\n                [8 /* transferred */]: 1 /* TRUE */,\n            },\n            [30 /* timeStamp */]: event.timeStamp,\n            [9 /* type */]: event.type,\n        },\n    });\n};\n/**\n * Process commands transfered from worker thread to main thread.\n * @param nodesInstance nodes instance to execute commands against.\n * @param worker whom to dispatch events toward.\n * @param mutation mutation record containing commands to execute.\n */\nexport function process(worker, mutation) {\n    const index = mutation[10 /* target */][7 /* _index_ */];\n    const target = getNode(index);\n    const shouldTrack = shouldTrackChanges(target);\n    let changeEventSubscribed = target.onchange !== null;\n    (mutation[21 /* removedEvents */] || []).forEach(eventSub => {\n        if (eventSub[9 /* type */] === 'change') {\n            changeEventSubscribed = false;\n        }\n        target.removeEventListener(eventSub[9 /* type */], KNOWN_LISTENERS[eventSub[32 /* index */]]);\n    });\n    (mutation[20 /* addedEvents */] || []).forEach(eventSub => {\n        if (eventSub[9 /* type */] === 'change') {\n            changeEventSubscribed = true;\n            target.onchange = null;\n        }\n        target.addEventListener(eventSub[9 /* type */], (KNOWN_LISTENERS[eventSub[32 /* index */]] = eventHandler(worker, index)));\n    });\n    if (shouldTrack && !changeEventSubscribed) {\n        applyDefaultChangeListener(worker, target);\n    }\n}\n//# sourceMappingURL=command.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNode, storeNode } from './nodes';\nimport { process, applyDefaultChangeListener } from './command';\nconst allTextNodes = (nodes) => nodes.length > 0 &&\n    [].every.call(nodes, (node) => ('nodeType' in node ? node.nodeType : node[0 /* nodeType */]) === 3 /* TEXT_NODE */);\n/**\n * Process MutationRecord from worker thread by comparing it versus the current DOM.\n * @param hydrationFromWorker contains mutations to compare or apply\n */\nexport function hydrate(mutations, baseElement, worker) {\n    // TODO(KB): Hydrations are not allowed to contain TransferredNodes.\n    // Perhaps we should create a TransferrableHydrationRecord.\n    const commands = [];\n    mutations.forEach(hydration => {\n        if (hydration[9 /* type */] === 2 /* CHILD_LIST */ && hydration[11 /* addedNodes */] !== undefined) {\n            (hydration[11 /* addedNodes */] || []).forEach((nodeToAdd, index) => {\n                if (nodeToAdd[8 /* transferred */] === 0 /* FALSE */) {\n                    const baseNode = getNode(hydration[10 /* target */][7 /* _index_ */]).childNodes[index] || baseElement;\n                    hydrateNode(baseNode, nodeToAdd, baseElement, worker);\n                }\n            });\n            // TODO(KB): Hydration can include changes to props and attrs. Let's allow mutation of attrs/props during hydration.\n        }\n        else if (hydration[9 /* type */] === 4 /* COMMAND */) {\n            commands.push(hydration);\n        }\n    });\n    // Processing order matters.\n    // For instance, Element.addEventListener requires the Element to exist first.\n    // Commands pass only the identifier for an element, and identifiers are stored in the main thread after the elements are created.\n    commands.forEach(command => process(worker, command));\n}\n/**\n * Stores the passed node and ensures all valid childNodes are hydrated.\n * @param node Real Node in DOM.\n * @param skeleton Skeleton Node representation created by WorkerDOM and transmitted across threads.\n */\nfunction hydrateElement(node, skeleton, baseElement, worker) {\n    if (skeleton[5 /* textContent */]) {\n        node.textContent = skeleton[5 /* textContent */];\n    }\n    storeNode(node, skeleton[7 /* _index_ */]);\n    // When hydrating an HTMLElement, there are some values that need to be synced to the background\n    // independently of if the background code has subscribed to an event on the Element.\n    // Primary Case: `<form><input><button onClick={function(){console.log(input.value)}} /></form>`\n    applyDefaultChangeListener(worker, node);\n    (skeleton[4 /* childNodes */] || []).forEach((childNode, index) => hydrateNode(node.childNodes[index], childNode, baseElement, worker));\n}\n/**\n * Compares the current node in DOM versus the skeleton provided during Hydration from worker thread.\n * Also, attempt to rationalize equivalence in output, but different by transmission nature.\n * @param node Real Node in DOM\n * @param skeleton Skeleton Node representation created by WorkerDOM and transmitted across threads.\n */\nfunction hydrateNode(node, skeleton, baseElement, worker) {\n    if (node.childNodes.length !== (skeleton[4 /* childNodes */] || []).length) {\n        // A limited number of cases when the number of childNodes doesn't match is allowable.\n        if (allTextNodes(node.childNodes)) {\n            if (skeleton[5 /* textContent */]) {\n                // Node with textContent but represented in SSR as Node.childNodes = [Text]\n                node.textContent = skeleton[5 /* textContent */];\n                storeNode(node, skeleton[7 /* _index_ */]);\n            }\n            else if (allTextNodes(skeleton[4 /* childNodes */] || [])) {\n                // Node with single textContent represented by multiple Text siblings.\n                // Some frameworks will create multiple Text nodes for a string, since it means they can update specific segments by direct reference.\n                // Hello, {name} => [Text('Hello, '), Text('user')]... Node.childNodes[1].textContent = 'another user';\n                node.removeChild(node.childNodes[0]);\n                (skeleton[4 /* childNodes */] || []).forEach(skeletonChild => {\n                    const skeletonText = document.createTextNode(skeletonChild[5 /* textContent */]);\n                    node.appendChild(skeletonText);\n                    storeNode(skeletonText, skeleton[7 /* _index_ */]);\n                });\n            }\n            return;\n        }\n        const validSkeletonChildren = (skeleton[4 /* childNodes */] || []).filter(childNode => !(childNode[0 /* nodeType */] === 3 /* TEXT_NODE */ &&\n            childNode[5 /* textContent */] === ''));\n        if (validSkeletonChildren.length === node.childNodes.length) {\n            hydrateElement(node, skeleton, baseElement, worker);\n        }\n    }\n    else {\n        hydrateElement(node, skeleton, baseElement, worker);\n    }\n}\n//# sourceMappingURL=hydrate.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNode, createNode } from './nodes';\nimport { process } from './command';\n// TODO(KB): Restore mutation threshold timeout.\n// const GESTURE_TO_MUTATION_THRESHOLD = 5000;\nlet MUTATION_QUEUE = [];\nlet PENDING_MUTATIONS = false;\nlet worker;\nexport function prepareMutate(passedWorker) {\n    worker = passedWorker;\n}\nconst mutators = {\n    [2 /* CHILD_LIST */](mutation, sanitizer) {\n        const parent = getNode(mutation[10 /* target */][7 /* _index_ */]);\n        const removedNodes = mutation[12 /* removedNodes */];\n        if (removedNodes) {\n            removedNodes.forEach(node => parent.removeChild(getNode(node[7 /* _index_ */])));\n        }\n        const addedNodes = mutation[11 /* addedNodes */];\n        const nextSibling = mutation[14 /* nextSibling */];\n        if (addedNodes) {\n            addedNodes.forEach(node => {\n                let newChild = getNode(node[7 /* _index_ */]);\n                if (!newChild) {\n                    newChild = createNode(node);\n                    if (sanitizer) {\n                        sanitizer.sanitize(newChild); // TODO(choumx): Inform worker?\n                    }\n                }\n                parent.insertBefore(newChild, (nextSibling && getNode(nextSibling[7 /* _index_ */])) || null);\n            });\n        }\n    },\n    [0 /* ATTRIBUTES */](mutation, sanitizer) {\n        const attributeName = mutation[15 /* attributeName */];\n        const value = mutation[18 /* value */];\n        if (attributeName != null && value != null) {\n            const node = getNode(mutation[10 /* target */][7 /* _index_ */]);\n            if (!sanitizer || sanitizer.validAttribute(node.nodeName, attributeName, value)) {\n                node.setAttribute(attributeName, value);\n            }\n            else {\n                // TODO(choumx): Inform worker?\n            }\n        }\n    },\n    [1 /* CHARACTER_DATA */](mutation, sanitizer) {\n        const value = mutation[18 /* value */];\n        if (value) {\n            // Sanitization not necessary for textContent.\n            getNode(mutation[10 /* target */][7 /* _index_ */]).textContent = value;\n        }\n    },\n    [3 /* PROPERTIES */](mutation, sanitizer) {\n        const propertyName = mutation[17 /* propertyName */];\n        const value = mutation[18 /* value */];\n        if (propertyName && value) {\n            const node = getNode(mutation[10 /* target */][7 /* _index_ */]);\n            if (!sanitizer || sanitizer.validProperty(node.nodeName, propertyName, value)) {\n                node[propertyName] = value;\n            }\n            else {\n                // TODO(choumx): Inform worker?\n            }\n        }\n    },\n    [4 /* COMMAND */](mutation) {\n        process(worker, mutation);\n    },\n};\n/**\n * Process MutationRecord from worker thread applying changes to the existing DOM.\n * @param hydrationFromWorker contains mutations to apply\n * @param nodes\n * @param worker\n */\nexport function mutate(mutations, sanitizer) {\n    //mutations: TransferrableMutationRecord[]): void {\n    // TODO(KB): Restore signature requiring lastMutationTime. (lastGestureTime: number, mutations: TransferrableMutationRecord[])\n    // if (performance.now() || Date.now() - lastGestureTime > GESTURE_TO_MUTATION_THRESHOLD) {\n    //   return;\n    // }\n    // this.lastGestureTime = lastGestureTime;\n    MUTATION_QUEUE = MUTATION_QUEUE.concat(mutations);\n    if (!PENDING_MUTATIONS) {\n        PENDING_MUTATIONS = true;\n        requestAnimationFrame(() => syncFlush(sanitizer));\n    }\n}\n/**\n * Apply all stored mutations syncronously. This method works well, but can cause jank if there are too many\n * mutations to apply in a single frame.\n *\n * Investigations in using asyncFlush to resolve are worth considering.\n */\nfunction syncFlush(sanitizer) {\n    const length = MUTATION_QUEUE.length;\n    MUTATION_QUEUE.forEach(mutation => mutators[mutation[9 /* type */]](mutation, sanitizer));\n    MUTATION_QUEUE.splice(0, length);\n    PENDING_MUTATIONS = false;\n}\n//# sourceMappingURL=mutate.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { hydrate } from './hydrate';\nimport { prepareMutate, mutate } from './mutate';\nimport { createWorker } from './worker';\nimport { prepare as prepareNodes } from './nodes';\nexport function install(baseElement, sanitizer) {\n    const authorURL = baseElement.getAttribute('src');\n    if (authorURL === null) {\n        return;\n    }\n    // console.log(`creating worker, author code: ${authorURL}`);\n    createWorker(authorURL).then(worker => {\n        if (worker === null) {\n            return;\n        }\n        prepareNodes(baseElement);\n        prepareMutate(worker);\n        worker.onmessage = ({ data }) => {\n            switch (data.type) {\n                case 2 /* HYDRATE */:\n                    // console.info(`hydration from worker: ${data.type}`, data.mutations);\n                    hydrate(data.mutations, baseElement, worker);\n                    break;\n                case 3 /* MUTATE */:\n                    // console.info(`mutation from worker: ${data.type}`, data.mutations);\n                    // mutationInstance.process(data.mutations);\n                    mutate(data.mutations, sanitizer);\n                    break;\n            }\n        };\n    });\n}\n//# sourceMappingURL=install.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { install } from './install';\nexport function upgradeElement(baseElement) {\n    install(baseElement);\n}\n//# sourceMappingURL=index.js.map"],"names":["prepare","baseElement","NODES","Map","BASE_ELEMENT","createNode","skeleton","Node","TEXT_NODE","_node","document","createTextNode","storeNode","node","namespace","createElementNS","createElement","attribute","namespaceURI","setAttributeNS","name","value","setAttribute","childNode","appendChild","getNode","id","get","nodeName","_index_","set","createWorker","authorScriptURL","Promise","all","fetch","__WORKER_DOM_URL__","then","response","text","workerScript","authorScript","keys","key","body","style","push","Worker","URL","createObjectURL","Blob","catch","error","process","worker","mutation","index","target","shouldTrack","shouldTrackChanges","changeEventSubscribed","onchange","eventSub","removeEventListener","KNOWN_LISTENERS","addEventListener","eventHandler","applyDefaultChangeListener","hydrate","mutations","commands","forEach","hydration","undefined","nodeToAdd","baseNode","childNodes","hydrateNode","command","hydrateElement","textContent","length","allTextNodes","removeChild","skeletonChild","skeletonText","filter","validSkeletonChildren","mutate","sanitizer","MUTATION_QUEUE","concat","PENDING_MUTATIONS","requestAnimationFrame","syncFlush","mutators","splice","install","authorURL","getAttribute","prepareNodes","onmessage","worker.onmessage","data","type","node.onchange","fireValueChange","postMessage","message","event","currentTarget","bubbles","cancelable","cancelBubble","defaultPrevented","eventPhase","isTrusted","returnValue","timeStamp","nodes","every","call","nodeType","parent","removedNodes","addedNodes","nextSibling","newChild","sanitize","insertBefore","attributeName","validAttribute","propertyName","validProperty","upgradeElement"],"mappings":"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"}